---
layout: post
category: tech
tags: [rails]
title: Rails学习笔记(5)
---

前面的章节主要是通过构建depot系统来熟悉rails的开发过程，然后进一步深入了解rails：  Rails in Depth. 

# Finding your way around Rails

## Rails directory structures:

	my_app/
	———————
	  |app/
	  ——————
	  |     |Model, view, and controller files go here.
	  |config/
	  ———————
	  |     |Configuration and database connection parameters.
	  |config.ru - Rack server configuration.
	  |db/
	  —————
	  |   |Schema and migration information.
	  |doc/
	  ——————
	  |    |Autogenerated documentation.
	  |Gemfile - Gem Dependencies.
	  |lib/
	  |————
	  |    |Shared code.
	  |log/
	  |————
	  |    |Log files produced by your application.
	  |public/
	  |———————
	  |      |Web-accessible directory. Your application runs from here.
	  |Rakefile - Build script.
	  |README - Installation and usage information.
	  |script/
	  |———————
	  |      |Utility scripts.
	  |test/
	  |—————
	  |    |Unit, functional, and integration tests, fixtures, and mocks.
	  |tmp/
	  |————
	  |   |Runtime temporary files.
	  |vendor/
	  |———————
	         |Imported code.

### text files:

* cinfig.ru: 配置Rack Webserver Interface. 
* Gemfile: 配置Rails的依赖组件。
* Gemfile.lock: 配置Rails依赖组件的版本。由bundler管理，一般要加入版本控制中。
* Rakefile: rake任务配置文件。
* README: Rails的一般信息。

### app

	app/
	————
	  |assets/
	  |———————
	  |     |images/
	  |     |————————
	  |     |javascripts/
	  |     |————————————
	  |     |stylesheets/
	  |     |————————————
	  |controllers/
	  |————————————
	  |helpers/
	  |————————
	  |mailers/
	  |————————
	  |models/
	  |———————
	  |views/
	  |——————
	        |layouts/
	        |————————
	        |products/
	        |—————————
	        |line_items/
	        |———————————


### 其他

lib目录中存放model、view、controller共用的一些代码。且需要在confie/application.rb 文件中显示加入path路径：

	config.autoload_paths += %W(#{Rails.root}/lib)
rake目录里存放自定义的rake任务。
script目录里存放脚本，rails默认的命令脚本也在里面，使用如`rails console`来执行。rails的命令包括：
* benchmarker
* console
* dbconsole
* destroy
* generate
* new
* plugin
* profiler
* runner
* server
## Naming conventions
模型与数据库表对应，模型类使用首字母大写方式命名，表名为小写加下划线方式，并以复数表示。
命名对应示例图：
<a href="http://www.flickr.com/photos/hutusi/11249886926/" title="Screenshot 2013-12-07 19.03.07.png by hutusi, on Flickr"><img src="http://farm6.staticflickr.com/5482/11249886926_24b1442e85.jpg" width="491" height="500" alt="Screenshot 2013-12-07 19.03.07.png"></a>### 将controller归类到Module
如果请求 admin/book, rails将找 app/controllers/admin 里的 book_controller, 而类定义也将包含在module中：
	class Admin::BookController < ActionController::Base
相应的view也会多出admin子目录。创建controller的命令：
	myapp> rails generate controller Admin::Book action1 action2 ...	
# Active Record
Active record是rails中的对象关系映射（ORM）层，即Model。
## 定义数据
每一个Model类（ActiveRecord::Base的子类）对应一个数据库表，且表名为类名的复数格式。如 LineItem ==> line_items. Rails可以处理规则的复数格式以及大部分的不规则复数形式（按照英语习惯，如辅音+y结尾==>ies, ch=>ches, sis=>ses, person=>people, datum=>data等），如果碰到复数处理不正确的情况，可以自定义规则添加到 config/initializers/inflections.rb 中。
<a href="http://www.flickr.com/photos/hutusi/11250254953/" title="Screenshot 2013-12-07 19.36.30.png by hutusi, on Flickr"><img src="http://farm3.staticflickr.com/2871/11250254953_d54b274aa1.jpg" width="500" height="124" alt="Screenshot 2013-12-07 19.36.30.png"></a>

如果原来已经有一数据库表而不想遵守这种规则，那么可以在Model类中声明：（不建议）

	class Sheep < ActiveRecord::Base	  self.table_name = "sheep"	end	
在rails console可以查看Model对应数据表的一些信息，如:

	depot> rails console
	>> Order.column_names	=> ["id", "name", "address", "email", "pay_type", "created_at", "updated_at"]	>> Order.columns_hash["pay_type"]	=> #<ActiveRecord::ConnectionAdapters::SQLiteColumn:0x7fe673f7da80	   @name="pay_type", @null=true, @default=nil, @sql_type="varchar(10)",	   @type=:string, @scale=nil, @precision=nil, @primary=false,@limit=10>### 数据库数据类型和Ruby类型对应转换
转换表：
<a href="http://www.flickr.com/photos/hutusi/11250288756/" title="Screenshot 2013-12-07 19.45.01.png by hutusi, on Flickr"><img src="http://farm8.staticflickr.com/7310/11250288756_4e8ed873ff.jpg" width="500" height="149" alt="Screenshot 2013-12-07 19.45.01.png"></a>如果需要原始数据，可以在列名后跟_before_type_cast 后缀，如：
	product.price_before_type_cast #=> "29.95", a string	product.updated_at_before_type_cast #=> "2008-05-13 10:13:14"在Model类中，可以使用私有方法read_attribute()和write_attribute()。
数据库decimal类型的数据，如果没有小树，则转换为Fixnum，否则转换为BigDecimal.
如果是Boolean类型，rails会默认提供一个带?的方法，如：	user = User.find_by_name("Dave")	if user.superuser?	  grant_privileges	end
### Active Record 的默认列
* created_at, created_on, updated_at, updated_on： _on后缀表示日期列，_at后缀表示时间列。	* lock_version: * type: 
* id: primary key列
* xxx_id: 连接以xxx复数形式命名的数据表的foreign key
* xxx_count: 


## Locating and traversing Records

Model之间通过id建立联系。Active Record类对应数据表，类实例对应表中的一行记录。rails默认以id作为primary key，也可以自己修改(除非是对已有表结构，否则不建议)：

	class LegacyBook < ActiveRecord::Base
	  self.primary_key = "isbn"	end

### Model之间的关系

三种：one-to-one, one-to-many, many-to-many. 使用如下声明来指定关系：has_one, has_many, belongs_to, has_and_belongs_to_many. 

#### one-to-one relationships

确切的讲，这种关系应该叫 one-to-zero-or-one relationship. 如下例，每个order有0或1个invoice.

<a href="http://www.flickr.com/photos/hutusi/11250612543/" title="Screenshot 2013-12-07 20.10.04.png by hutusi, on Flickr"><img src="http://farm8.staticflickr.com/7329/11250612543_00a71a329a.jpg" width="500" height="178" alt="Screenshot 2013-12-07 20.10.04.png"></a>

has_one说明是one-to-one. 

规则（适用于其他关系）：拥有foreign key（例如order_id）的model总是要使用belongs_to声明。

#### one-to-many relationships

<a href="http://www.flickr.com/photos/hutusi/11250586895/" title="Screenshot 2013-12-07 20.16.20.png by hutusi, on Flickr"><img src="http://farm8.staticflickr.com/7423/11250586895_efc5fd64a5.jpg" width="500" height="188" alt="Screenshot 2013-12-07 20.16.20.png"></a>

注意belongs_to 和 has_many.

#### many-to-many relationships

例如，一个产品可能属于多个类别，而一个类别也可以有多个产品。

<a href="http://www.flickr.com/photos/hutusi/11250761313/" title="Screenshot 2013-12-07 20.24.20.png by hutusi, on Flickr"><img src="http://farm4.staticflickr.com/3748/11250761313_c764ef6924.jpg" width="500" height="154" alt="Screenshot 2013-12-07 20.24.20.png"></a>
两个model都使用了has_and_belongs_to_many (habtm)声明。
rails实现many-to-many关系是通过一个中间媒介的连接表（如例中categories_products），它包含了一对foreign key连接两个表。
## CRUD (Creating, Reading, Updating, Deleting)### Creating new rows
使用Active Record类的new()方法（构造函数）和save()方法，创建实例并保存到数据表中。也可以使用Create()方法，相当与new + save， 且create参数中可传数组。
### Reading exsiting rows
find(): 参数是primary key或primary key数组，如果找不到任一个记录将抛出 RecordNotFound异常。
#### Dynamic findersfind_by_xxx(): xxx为Model的属性。方法有：find\_by\_(), find_last_by\_(), find_all\_by_(). 如：	order = Order.find_by_name("Dave Thomas")	orders = Order.find_all_by_name("Dave Thomas")	orders = Order.find_all_by_email(params['email'])其中 `order = Order.find_by_name("Dave Thomas")` 会被rails转换为 `order = Order.where(name: "Dave Thomas").first`. 相应的，find_all_by_ 对应 all(), find_last_by_ 对应 last().
这些方法如果找不到记录会返回nil, 如果在调用加了!后缀的find_by_方法找不到记录将会抛RecordNotFound异常，如：
	order = Order.find_by_name!("Dave Thomas")
这种方法还可以传入多个列值，如：
	user = User.find_by_name_and_password(name, pw)
等价于：
	user = User.where(name: name, password: pw).first
对于列名中含有 \_and_ 字符时find_by就不大合适了，得改用where方法。
另外，有时想如果查不到则新增一条记录，那么可以用 find_or_initialize_by_() 方法或 find_or_create_by\_() 方法.同样，这些方法对于列名中含 \_or\_ 或 \_and\_ 的情形不适用。
#### SQL and Active Record
一个简单的where查询方法：
	pos = Order.where("name = 'Dave' and pay_type = 'po'")如果想要使参数参数为变量：
	# get the name from the form	name = params[:name]	# DON'T DO THIS!!!	pos = Order.where("name = '#{name}' and pay_type = 'po'")不能这样写，因为这样暴露了数据库会导致SQL注入攻击(SQL injection attack), 安全的办法是让Active Record处理动态SQL。可以采用占位符(placeholder)的办法：
	name = params[:name]	pos = Order.where(["name = ? and pay_type = 'po'", name])第一个?被第二个参数替换，如果有多个？则被后面的参数依次替换。也可以对占位符命名：
	name = params[:name]	pay_type = params[:pay_type]	pos = Order.where("name = :name and pay_type = :pay_type",                  pay_type: pay_type, name: name)

因为params是一个hash，所以可以简化上述语句：
		
		pos = Order.where("name = :name and pay_type = :pay_type", params[:order])

还可以再简化：

	pos = Order.where(params[:order])
	
但这样会将整个params的hash都作为查询条件，可以更明确的指定参数：

	pos = Order.where(name: params[:name],                  pay_type: params[:pay_type])

#### Using like clauses

有时候想要使用like语句来查询：

	# Doesn't work	User.where("name like '?%'", params[:name])

这样不行，要使用下面的方式：

	# Works	User.where("name like ?", params[:name]+"%")#### Subsetting the records returned
查询的返回结果类型为ActiveRecord::Relation, 它支持多种方法如：first(), all(), each(), map()等。
##### order
	orders = Order.where(name: 'Dave'). order("pay_type, shipped_at DESC")

##### limit

	orders = Order.where(name: 'Dave'). order("pay_type, shipped_at DESC"). limit(10)##### offset
与limit一起用：
	# The view wants to display orders grouped into pages,	# where each page shows page_size orders at a time.	# This method returns the orders on page page_num (starting # at zero).	def Order.find_on_page(page_num, page_size)	  order(:id).limit(page_size).offset(page_num*page_size)	end##### select
默认情况下ActiveRecord::Relation获取数据表里的所有列，即`select * from ...`, 如果要取指定列可使用 select() 方法： 
	list = Talk.select("title, speaker, recorded_on")
##### joins

多表连接查询：
	LineItem.select('li.quantity').	  where("pr.title = 'Programming Ruby 1.9'").	  joins("as li inner join products as pr on li.product_id = pr.id")

##### readonly

使用`readonly()`查询返回的对象不能被保存回数据库。使用joins()和select()方法查询出的对象自动被标记为readonly.

##### group

	summary = LineItem.select("sku, sum(amount) as amount").group("sku")

##### lock

	Account.transaction do	  ac = Account.where(id: id).lock("LOCK IN SHARE MODE").first ac.balance -= amount if ac.balance > amount	  ac.save	end

使用 lock(), 数据库锁被获取("for update"状态)。一般使用transaction来代替lock.


#### Get column statistics

	average = Order.average(:amount) # average amount of orders
	max = Order.maximum(:amount)	min = Order.minimum(:amount)	total = Order.sum(:amount)	number  = Order.count

这些方法也可以合并使用：

	Order.where("amount > 20").minimum(:amount)

#### Scopes

定义scope方便重用查询方法，如定义：

	class Order < ActiveRecord::Base	  scope :last_n_days, lambda { |days| where('updated < ?' , days) }	end

使用：

	orders = Order.last_n_days(7)

再定义：

	scope :checks, where(pay_type: :check)

scope可以组合使用：

	orders = Order.checks.last_n_days(7)

而ActiveRecord::Relation的对象也可以理解为室匿名scope：

	in_house = Order.where('email LIKE "%@pragprog.com"')

与其他scope组合使用：
	in_house.checks.last_n_days(7)

#### writing our own SQL

find_by_sql(),完全使用SQL:

	orders = LineItem.find_by_sql("select line_items.* from line_items, orders " + " where order_id = orders.id " + " and orders.name = 'Dave Thomas' ")
	
也可以使用placeholder传入数组的形式:

	Order.find_by_sql(["select * from orders where amount > ?", params[:amount]])
	
#### Reloading data

在多进程并行操作数据库的场景下，需要即使获得最新数据。一般使用transaction解决这个问题，或使用 reload()方法。


### Updating existing rows

如果Active Record对象是从数据表中读取出的，那么调用save()将存回数据表：

	order = Order.find(123)
	order.name = "Fred"
	order.save

如果使用find_by_sql()，要包含id，才能修改后save：

	orders = Order.find_by_sql("select id, name, pay_type from orders where id=123")
	
另外，可用 update_attribute()和 update_attributes()方法：

	order = Order.find(123)
	order.update_attribute(:name, "Barney")	order = Order.find(321)
	order.update_attributes(name: "Barney", email: "barney@bedrock.com")
指定id使用update(),或 update_all()更新指定集合的数据：
	order = Order.update(12, name: "Barney", email: "barney@bedrock.com")
	result = Product.update_all("price = 1.1*price", "title like '%Java%'")
#### save, save!, create, create!

* save 成功返回true, 失败返回nil
* save! 成功返回true, 失败抛异常
* create 无论成功与否都返回Active Record对象，需要校验数据是否被写入
* create! 成功返回Active Record对象，失败抛异常

### Deleting rows
Active Record提供两种形式的删除：
一种是delete(), delete_all(). 类的静态方法，如果数据行不存在将会抛异常。
delete()参数为单个id或id数组：
	Order.delete(123)	User.delete([2,3,4,5])	
delete_all()按条件删除：
	Product.delete_all(["price > ?", @expensive_price])另一种删除是destroy(), destroy_all(). destroy是对象方法，它将对象冻结，后续将不能被修改。
	order = Order.find_by_name("Dave")	order.destroy	# ... order is now frozen	Order.destroy_all(["shipped_at < ?", 30.days.ago])## Paticipating in the Monitoring Process

在Active Record类中加入callback监视数据变化，如before_destroy(), after_destroy(). 

Sequence of Active Record callbacks:

<a href="http://www.flickr.com/photos/hutusi/11289289144/" title="Screenshot 2013-12-09 21.09.10.png by hutusi, on Flickr"><img src="http://farm8.staticflickr.com/7411/11289289144_2bd2e09d3f.jpg" width="500" height="285" alt="Screenshot 2013-12-09 21.09.10.png"></a>

除了这些callback, 还有after_find(), after_initialize(),但这两个事件有些特殊，由于性能优化的考虑，它们只有在被定义成方法的情况下才会被callback,而声明handler的方式会被忽略.定义callback的方法可以是声明handler，也可以是方法或者程序块：	class Order < ActiveRecord::Base	  before_validation :normalize_credit_card_number
	  after_create do |order|	    logger.info "Order #{order.id} created"	  end
	  protected	  def normalize_credit_card_number	    self.cc_number.gsub!(/[-\s]/, '')	  end	end也可以直接定义callback方法：

	class Order < ActiveRecord::Base	  def before_save	    self.payment_due ||= Time.now + 30.days
	  end
	end

### Grouping related callbacks together

将相关的callback归类在一起，便于重用，如: 方法名为callback事件，接受一个参数Model对象。
	class CreditCardCallbacks	  # Normalize the credit card number	  def before_validation(model) 	    model.cc_number.gsub!(/[-\s]/, '')	  end	end
		class Order < ActiveRecord::Base	  before_validation CreditCardCallbacks.new	  # ...	end	class Subscription < ActiveRecord::Base	  before_validation CreditCardCallbacks.new	  # ...	end
而这种写法则让调用者依赖了实现细节（如cc_number）, 重构成如下方式：

	class Encrypter		# We're passed a list of attributes that should be stored encrypted in the database		def initialize(attrs_to_manage)		  @attrs_to_manage = attrs_to_manage		end			   # Before saving or updating, encrypt the fields using the NSA and DHS approved Shift Cipher	   def before_save(model)	     @attrs_to_manage.each do |field|	       model[field].tr!("a-z", "b-za")	     end 	   end
	   # After saving, decrypt them back	   def after_save(model)	     @attrs_to_manage.each do |field|	       model[field].tr!("b-za", "a-z")	     end	   end
	   # Do the same after finding an existing record	   alias_method :after_find, :after_save	 end调用处：
	require "encrypter"		class Order < ActiveRecord::Base	  encrypter = Encrypter.new([:name, :email])	  	  before_save encrypter	  after_save  encrypter	  after_find  encrypter	  	protected	  def after_find 	  end	end注意：这里定义了一个空的after_find()方法；原因是如前面所述，由于性能优化原因after_find和after_initialize如果不被定义成方法的话会被忽略，所以定义成空方法来触发回调。
还可以把加密方法放到基类里:
	class ActiveRecord::Base	  def self.encrypt(*attr_names)	    encrypter = Encrypter.new(attr_names)	    before_save encrypter	    after_save  encrypter	    after_find  encrypter	    define_method(:after_find) { }	  end	end而使用时：
	class Order < ActiveRecord::Base	  encrypt(:name, :email)	end### observersActive Record Observer建立了与之对应的Model类的联系，是观察者模式在rails中的应用，且一句COC原则，Observer派生出的类，类名去掉后面的Observer即为观察的Model类：	class OrderObserver < ActiveRecord::Observer	  def after_save(an_order)	    an_order.logger.info("Order #{an_order.id} created")	  end	end也可以显示指定所观察的类（可不遵守命名习惯）：
	class AuditObserver < ActiveRecord::Observer	  observe Order, Payment, Refund	  def after_save(model)	    logger.info("[Audit] #{model.class.name} #{model.id} created")	  end	endobserver源码都存放在app/models下。
#### instantiating observers

在rails里使用observer:

	config.active_record.observers = :order_observer, :audit_observer## Transactions
transaction保证对数据库的操作完整性，如果其中一步没有成功，那么其他操作也不会生效。	Account.transaction do	  account1.deposit(100)	  account2.withdraw(100)	end

### Built-in Transactions

save(), destroy()...
